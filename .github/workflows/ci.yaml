name: Integration Test WF
on: 
  push:
    branches:
      - master
  pull_request:
    branches:
      - master
env:
  KIND_URL: https://kind.sigs.k8s.io/dl
  KIND_VER: v0.8.1
  KIND_ENV: kind-linux-amd64

jobs:
  Connector-Tests:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout the current repo
        uses: actions/checkout@v1
      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            kafkachanges: 
              - 'kafka-http-connector/**'
            rabbitmqchanges: 
              - 'rabbitmq-http-connector/**'   
            sqschanges:  
              - 'aws-sqs-http-connector/**' 
            natschanges:
              - 'nats-streaming-http-connector/**'                                             
      - name: Install Kind Cluster
        run: |
          curl -Lo ./kind $KIND_URL/$KIND_VER/$KIND_ENV      
          chmod +x ./kind
          sudo mv ./kind /usr/bin/
      - name: Install KEDA using HELM    
        run: |
          cd test/
          ./registry.sh
          helm repo add kedacore https://kedacore.github.io/charts
          helm repo update
          kubectl create namespace keda
          helm install keda kedacore/keda --namespace keda
      - name: Install Fission and it's cli
        run: |
          kubectl create namespace fission
          git clone --single-branch --branch natsConn https://github.com/girishg4t/fission.git
          cd fission/charts/fission-core 
          helm dependency update .
          helm install fission-app . --set mqt_keda.enabled=true \
          --set mqt_keda.connector_images.nats_steaming.image=localhost:5000/nats-steaming \
          --set mqt_keda.connector_images.nats_steaming.tag=latest \
          --set mqt_keda.connector_images.awssqs.image=localhost:5000/aws-sqs-test-connector \
          --set mqt_keda.connector_images.awssqs.tag=latest \
          -n fission
          curl -Lo fission https://github.com/fission/fission/releases/download/1.11.1/fission-cli-linux \
          && chmod +x fission && sudo mv fission /usr/local/bin/     
      - name: Create HTTP server using fission  
        run: |
          cd test/http-endpoint
          fission environment create --name go --image fission/go-env-1.12:1.11.1 --builder fission/go-builder-1.12:1.11.1
          fission fn create --name helloworld --env go --src hello.go --entrypoint Handler --executortype newdeploy \
          --minmemory 64 --maxmemory 128 --minscale 1 --maxscale 6  --targetcpu 50
      - name: Create Docker Image for Nats Streaming KEDA Connector
        if: steps.filter.outputs.natschanges == 'true'  
        run: |
          cd nats-streaming-http-connector/
          docker build -t localhost:5000/nats-steaming:latest .
          docker push localhost:5000/nats-steaming:latest
      - name: Create Nats Streaming server
        if: steps.filter.outputs.natschanges == 'true'  
        run: |
          cd nats-streaming-http-connector/test/nats-streaming-server
          kubectl apply -f nats-dep.yaml    
      - name: Publish messages to nats server
        if: steps.filter.outputs.natschanges == 'true'     
        run: |
          cd nats-streaming-http-connector/test/producer
          docker build -t localhost:5000/producer:latest .
          docker push localhost:5000/producer:latest
          kubectl create deployment nats-pub --image=localhost:5000/producer:latest   
          kubectl wait pod -l app=nats-pub --for=condition=ready --timeout=30s
      - name: Run fission for nats connector
        if: steps.filter.outputs.natschanges == 'true'  
        run: |
          fission mqt create --name natstest --function helloworld --mqtype stan --topic hello --resptopic response --mqtkind keda --errortopic error --maxretries 3 --metadata subject=hello --metadata queueGroup=grp1 --metadata durableName=due --metadata natsServerMonitoringEndpoint=nats.default.svc.cluster.local:8222 --metadata clusterId=test-cluster --metadata clientId=stan-sub --metadata natsServer=nats://nats:4222
      - name: Validate and test nats connector
        if: steps.filter.outputs.natschanges == 'true'
        run: |
          sleep 2 
          kubectl get pods
          kubectl wait pod -l app=natstest --for=condition=ready --timeout=30s 
          kubectl logs -l app=natstest --all-containers=true        
      - name: Create Docker Image for Kafka KEDA Connector
        if: steps.filter.outputs.kafkachanges == 'true'      
        run: |
          cd kafka-http-connector/
          docker build -t localhost:5000/kafka-connector:latest .
          docker push localhost:5000/kafka-connector:latest
      - name: Create Kafka Docker Image for Consumer
        if: steps.filter.outputs.kafkachanges == 'true'      
        run: |
          cd kafka-http-connector/test/consumer/
          docker build -t localhost:5000/consumer:latest .
          docker push localhost:5000/consumer:latest
      - name: Deploy Kafka cluster
        if: steps.filter.outputs.kafkachanges == 'true'      
        run: |
          cd kafka-http-connector/test/kubernetes/
          kubectl create namespace kafka
          curl -L http://strimzi.io/install/latest | sed 's/namespace: .*/namespace: kafka/' | kubectl apply -f - -n kafka
          sleep 10s
          kubectl apply -f kafka-cluster.yaml
          echo "Kafka Cluster is getting up."
          kubectl wait -f kafka-cluster.yaml --for=condition=ready --timeout=-1s -n kafka
          sleep 2m
          kubectl get pods -n kafka
          kubectl wait pod -l app.kubernetes.io/name=zookeeper --for=condition=ready --timeout=-1s -n kafka
      - name: Create Kafka topics
        if: steps.filter.outputs.kafkachanges == 'true'      
        run: |
          cd kafka-http-connector/test/kubernetes/
          kubectl apply -f kafka-req-topic.yaml
          kubectl apply -f kafka-err-topic.yaml
          kubectl apply -f kafka-res-topic.yaml
      - name: Run fission for kafka connector
        if: steps.filter.outputs.kafkachanges == 'true'  
        run: |
          fission mqt create --name kafkatest --function helloworld --mqtype kafka  --mqtkind keda --topic request-topic --resptopic response-topic --errortopic error-topic --maxretries 3 --metadata bootstrapServers=my-cluster-test-kafka-bootstrap.kafka.svc:9092 --metadata consumerGroup=bridge-quickstart-consumer-group --metadata topic=request-topic  --cooldownperiod=30 --pollinginterval=5
          sleep 15s
      - name: Produce Kafka messages Using Producer
        if: steps.filter.outputs.kafkachanges == 'true'      
        run: |
          cd kafka-http-connector/test/kubernetes/
          kubectl apply -f kafka-produer.yaml
          kubectl wait -f kafka-produer.yaml --for=condition=complete --timeout=-1s
          kubectl delete job pi
          kubectl logs -f -l app=kafkatest --all-containers=true
      - name: Create Docker Image for Rabbitmq KEDA Connector
        if: steps.filter.outputs.rabbitmqchanges == 'true'        
        run: |
          cd rabbitmq-http-connector/
          docker build -t localhost:5000/rabbit-keda:latest .
          docker push localhost:5000/rabbit-keda:latest
      - name: Create Rabbitmq Docker Image for Publisher
        if: steps.filter.outputs.rabbitmqchanges == 'true'        
        run: |
          cd rabbitmq-http-connector/test/publisher/
          docker build -t localhost:5000/rabbit-publisher:latest .
          docker push localhost:5000/rabbit-publisher:latest
      - name: Create Rabbitmq Docker Image for Consumer
        if: steps.filter.outputs.rabbitmqchanges == 'true'        
        run: |
          cd rabbitmq-http-connector/test/consumer/
          docker build -t localhost:5000/rabbit-consumer:latest .
          docker push localhost:5000/rabbit-consumer:latest
      - name: Deploy Rabbitmq Deployment files
        if: steps.filter.outputs.rabbitmqchanges == 'true'        
        run: |
          cd rabbitmq-http-connector/test/kubernetes/
          kubectl create ns rabbits
          kubectl apply -n rabbits -f rabbit-rbac.yaml
          kubectl apply -n rabbits -f rabbit-configmap.yaml
          kubectl apply -n rabbits -f rabbit-secret.yaml
          kubectl apply -n rabbits -f rabbit-statefulset.yaml
          bash rabbitmq-cluster-instances.sh 
      - name: Publish Rabbitmq messages in a queue
        if: steps.filter.outputs.rabbitmqchanges == 'true'        
        run: |
          cd rabbitmq-http-connector/test/publisher/
          kubectl apply -f deployment.yaml
          kubectl apply -f publisher-job.yaml
      - name: Bring up the Rabbitmq consumer queue and Listen for incoming messages
        if: steps.filter.outputs.rabbitmqchanges == 'true'        
        run: |
          cd rabbitmq-http-connector/test/consumer/
          kubectl apply -f consumer-deployment.yaml          
      - name: Run fission for rabbitmq connector
        if: steps.filter.outputs.rabbitmqchanges == 'true'  
        run: |
          fission mqt create  --name rabbittest --function helloworld --mqtype rabbitmq --topic request --resptopic response --mqtkind keda --errortopic error --maxretries 3 --metadata queueName=request  --cooldownperiod=30 --pollinginterval=5 --secret rabbitmq-consumer
      - name: Get Rabbitmq consumed messages from queue
        if: steps.filter.outputs.rabbitmqchanges == 'true'        
        run: |
          sleep 10s
          kubectl logs  -n rabbits deployment.apps/rabbitmq-consumer
      - name: Create Docker Image for SQS KEDA Connector
        if: steps.filter.outputs.sqschanges == 'true'        
        run: |
          cd aws-sqs-http-connector
          docker build -t localhost:5000/aws-sqs-connector:latest .
          docker push localhost:5000/aws-sqs-connector:latest
      - name: Create SQS Docker image with AWS CLI in KEDA Connetor
        if: steps.filter.outputs.sqschanges == 'true'        
        run: |
          cd aws-sqs-http-connector/test/kubernetes 
          docker build -t localhost:5000/aws-sqs-test-connector:latest .
          docker push localhost:5000/aws-sqs-test-connector:latest
      - name: Deploy SQS Keda Connector, Keda ScaledObject and Localstack
        if: steps.filter.outputs.sqschanges == 'true'        
        run: |
          cd aws-sqs-http-connector/test/kubernetes 
          fission mqt create  --name sqstest --function consumer --mqtype aws-sqs-queue --topic request --resptopic response --mqtkind keda --errortopic error --maxretries 3 --metadata queueURL=http://localstack:31000/queue/request --identityOwner=operator --metadata awsRegion=us-east-1 --cooldownperiod=30 --pollinginterval=5
          kubectl apply -f localstack.yaml
      - name: Build and Deploy SQS test queue
        if: steps.filter.outputs.sqschanges == 'true'        
        run: |       
          cd aws-sqs-http-connector/test/validate
          docker build -t localhost:5000/test-queue:latest .
          docker push localhost:5000/test-queue:latest
          kubectl apply -f test.yaml
          sleep 10s
          kubectl get pods
          kubectl wait pod -l app=sqstest --for=condition=ready --timeout=200s
      - name: Get SQS consumed messages from queue
        if: steps.filter.outputs.sqschanges == 'true'        
        run: |
          sleep 30s
          kubectl logs -l app=sqstest          